// Try to use this RLE algorithm to compress some hexadecimal data(RGB images usually have a lot of repeated characters)

// TODO:
//   Test it with different hex data combinations(I didn't tested it, feel free to test it)

import scala.math.sqrt

object RLE_with_Base71 {
	// This data is a 25x25 RGB image(randomly generated by typing some random hex values)
	// Oops, I forgot that this is hexadecimal RGB(3), so the full size is 25*25*3
	val data: String = "F80EB1FEABACAC0CAFC01A007FEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF42FBCBFF8F420CC3FF1F2FFD4FFFFFFFDDDDCFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEEE999EEEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFBADC0DEFFF12FFFFF11FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF33FFFFFF44FFFFFFFFFF22FFFFFFFFFFFFFFFFFFFFFFFFABCDFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF4444FFFFFFFF5555FFFFFFFFFFB00B5FFF3FFFFFFF666666FF63626FFFFFFFFFF852FF77FFFFFAFFFBFFF54422AABCCDDDDFFFFA1A2A3A9AAAA8AAAA7AAAAFFFFFFFFFF88FFFFFFFFFFFFFFFFFF1337FFFFFFFFFFFFFFFFFFFFFFFFFFFFFF2314019FFFFF9FFF99F5F499FFFF000FFFFFFFFF33F42F80EB1FEABACAC0CAFC01A007FEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF42FBCBFF8F420CC3FF1F2FFD4FFFFFFFDDDDCFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEEE999EEEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFBADC0DEFFF12FFFFF11FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF33FFFFFF44FFFFFFFFFF22FFFFFFFFFFFFFFFFFFFFFFFFABCDFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF4444FFFFFFFF5555FFFFFFFFFFB00B5FFF3FFFFFFF666666FF63626FFFFFFFFFF852FF77FFFFFAFFFBFFF54422AABCCDDDDFFFFA1A2A3A9AAAA8AAAA7AAAAFFFFFFFFFF88FFFFFFFFFFFFFFFFFF1337FFFFFFFFFFFFFFFFFFFFFFFFFFFFFF2314019FFFFF9FFF99F5F499FFFF000FFFFFFFFF33F42F80EB1FEABACAC0CAFC01A007FEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF42FBCBFF8F420CC3FF1F2FFD4FFFFFFFDDDDCFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEEE999EEEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFBADC0DEFFF12FFFFF11FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF33FFFFFF44FFFFFFFFFF22FFFFFFFFFFFFFFFFFFFFFFFFABCDFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF4444FFFFFFFF5555FFFFFFFFFFB00B5FFF3FFFFFFF666666FF63626FFFFFFFFFF852FF77FFFFFAFFFBFFF54422AABCCDDDDFFFFA1A2A3A9AAAA8AAAA7AAAAFFFFFFFFFF88FFFFFFFFFFFFFFFFFF1337FFFFFFFFFFFFFFFFFFFFFFFFFFFFFF2314019FFFFF9FFF99F5F499FFFF000FFFFFFFFF33F42"
	val separator: String = "," // Let the comma for historic research of wrong code(It still may work somewhere)

	// Base 71(Excludes Only Hexadecimal values and non readable(ASCII) and maybe others(idk XD))
	val RLE_CUSTOM_NUMBER_TABLE71 = "GHIJKLMNOPQRSTUVWXYZghijklmnopqrstuvwxyz.,><:;/|\\[]()!?@#$%&*§_=+~^'´`\""
	def dec2b71(dec: Int): String = {
	  var B71 = ""
	  var D = dec
	  if (D == 0)
	    B71 += RLE_CUSTOM_NUMBER_TABLE71(D)
	  while (D > 0) {
	    B71 += RLE_CUSTOM_NUMBER_TABLE71(D % 71).toString
	    D = D / 71
	  }
	  B71
	}
	// That's it, I've just created a "Base 71 Numeric System"
	// You can test it by using b712dec(dec2b71(203)) == 203
	
	// The problem is that this system uses reversed numbers,
	// in decimal it would look like you've stored
	// the numbers in reverse(01 would be 10).
	
	// It's not a bug, it's a feature(well at least for me it works)
	def b712dec(B71: String): Int = {
	  var Dec = RLE_CUSTOM_NUMBER_TABLE71.indexOf(B71(0))
	  for (i <- 1 until B71.length) {
	    Dec += RLE_CUSTOM_NUMBER_TABLE71.indexOf(B71(i)) * (i*71)
	  }
	  Dec
	}
	def main(args: Array[String]): Unit = {
	  // You can get the width and height of a image by the
	  // square root of data length(if the width and height are equal)
	  // sqrt(length) = width * height
	  //val imgSize = sqrt(data.length) // imgSize works as width/height
	  
	  // RLE COMPRESS METHOD(My version tho)
	  // You can't compress if there's commas in the data("234,Data,FFF")
	  
	  // This will hold the char and the char repeat count(duplicate)
	  // Compressed Data Array = Counts Array + Values Array
	  var RLE_Counts = List[String]()
	  var RLE_Values = List[String]()
	  
		var ac = ""
		var C = 0
		for (i <- 0 until data.length) {
		  if (ac.contains(data(i))) {
		    C += 1
		  } else {
		    if (ac != "") {
		      RLE_Counts = RLE_Counts :+ dec2b71(C)
		      RLE_Values = RLE_Values :+ ac
		      ac = ""
		    }
		    C = 1
		    ac = data(i).toString
		  }
		}
		if (ac != "") { // Always the last one is left
		  RLE_Counts = RLE_Counts :+ dec2b71(C)
		  RLE_Values = RLE_Values :+ ac
		}
		// Here's we're gonna join the char count with the respective values(separated by comma ",")
		// UPDATE > Comma data separation is removed:
		//  - Good Thing = Data with more Compression Rate(48.16%).
		//  - Bad Thing = I will need to write a more complex and difficult code to decompress it(YAY, I've finished it!).
		var RAW_RLE_DATA = "" 
		for (i <- 0 until RLE_Values.length)
		  RAW_RLE_DATA += RLE_Counts(i) + RLE_Values(i)
		
		
		println(f"Original Data:\n${data}\nLength:${data.length}\n\nRLE Compressed Data:\n${RAW_RLE_DATA}\nLength:${RAW_RLE_DATA.length}\n\nCompression Rate:${100.00-RAW_RLE_DATA.length.toDouble/data.length.toDouble*100.00}%.2f%%")
		// RLE DECOMPRESS METHOD
		var RAW_DATA = "" // Must give the same result as "data"(same length, same data)
		//val SPLIT_RLE_DATA = RAW_RLE_DATA.split(separator) - Wrong!
		
		// I will just reuse them
		var RLE_DCounts = List[Int]()
	  RLE_Values = List[String]()
		var RD = ""
		ac = ""
		for (i <- 0 until RAW_RLE_DATA.length) {
		  RD = RAW_RLE_DATA(i).toString
		  if (RLE_CUSTOM_NUMBER_TABLE71.contains(RAW_RLE_DATA(i))) {
		    ac += RD
		  } else {
		    if (ac != "") {
		      RLE_DCounts = RLE_DCounts :+ b712dec(ac)
		      RLE_Values = RLE_Values :+ RD
		      ac = ""
		    }
		  }
		}
		if (ac != "") {
		  RLE_DCounts = RLE_DCounts :+ b712dec(ac)
		  RLE_Values = RLE_Values :+ RD
		}
		for (y <- 0 until RLE_Values.length) {
		  for (x <- 0 until RLE_DCounts(y))
		    RAW_DATA += RLE_Values(y)
		}
		println(f"RLE Decompressed Data:\n${RAW_DATA}\nDecompressed Length:${RAW_DATA.length}\n")
		println(f"The original data and the decompressed data have the same size?")
		if (data.length==RAW_DATA.length)
		  println("Yes")
		else
		  println("No")
		println(f"\nThe original data and the decompressed data have the same content?")
		if (data==RAW_DATA)
		  println("Yes")
		else
		  println("No")
	}

}
// Some comments are just not totally related(like in the image size), so it may be confusing to understand how it works, just focus on my custom RLE algorithm, I would answer your questions for a better understanding but not in time, probably it can even take a week for me reply

